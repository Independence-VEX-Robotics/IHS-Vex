
#pragma config(Sensor, dgtl1,  rightencoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftencoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           righttop,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           rightbottom,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           lift1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           lift2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lefttop,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftbottom,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           hang,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// -------->>>   replace this comment with motor and sensor setup code   <<<--------- //

#pragma DebuggerWindows("debugStream")

// HOW TO USE THIS RECORDER:
// 1. Paste the motor control code from your competition template at line 1 above.
// 2. Paste the user control code from your competition template in the userControlCode function
// 3. Adjust R_mSec and R_Freq values if you want a different length or frequency of recording
// 4. Have a game field set up and a driver ready to drive the bot for an autonomous run.
// 5. While using the programming cable with the controller connected to the robot via vexNet, download this code.
// 6. With the debug stream window open, press start to run the code. There will be a 3 second count down before user control starts.
// 7. Copy the text from the debug stream window into your autonomous task.
// 8. Copy the variables and function between /*---- START COPY -- and --END COPY-------*/ into your competition template above the pre-autonomous task.

int R_mSec = 15000; // 15000, length of autonomous redording in miliseconds

int loopCounter; // the number of each loop of code
int timeCounter; // the time in mS of each loop
int motorValue[10]; // array of motor values updated in userControlCode
int motorValue_Last[10]; // motor values of previous loop
bool motorChange = false; // any motor change within the last loop sets to true
int	loopOfLastChange; // last loop any motor value changed
int	timeSinceLastChange; // calculate each loop motorChange = false

/*---- START COPY -----------------------------------------------------------------------------------------------------------------------*/

int R_Batt; // the battery voltage at the time of the recording.
int R_Freq = 50; // 50 the frequency of the recording in milisecons. A lower number will attempt to capture more data, but may result in errors in the recording
int P_Freq = 50; // the replay frequency in miliseconds, calculated in replayFreq()

// function to assess battery voltage and adjust replay frequency
void replayFreq()
{
	// with R_Freq at 100, there would be ~1mS difference in playback per 80mV difference in voltage
	// recording at 8200mV and playback at 7200mV would make P_Freq = 113mS, meaning the last ~2 secs would be stopped by competition control
	P_Freq = R_Freq * (R_Batt / nImmediateBatteryLevel);
}

/*-------------------------------------------------------------------------------------------------------------------------END COPY-------*/

// function to hold user control code
void userControlCode()
{

	// ---->>>       replace this comment with your user control code, everything within the while(true) brackets        <<<---- //
	// ---->>>  if you are using global variables or fucntions, they must be coppied into this code above this function  <<<---- //

	for (int m = 0; m < 10; m++)
	{
		motorValue[m] = motor[m];
	}
}

// task to record motor value changes to the debug stream
task recordMotorValues()
{
	// initialize arrays to 0
	for (int m = 0; m < 10; m++)
	{
		motorValue[m] = 0;
		motorValue_Last[m] = 0;
	}

	while(true)
	{
		// increment loopCounter
		loopCounter++;

		for (int m = 0; m < 10; m++)
		{
			if(motorValue[m] != motorValue_Last[m]) // if motorValue changes from last loop
			{
				writeDebugStream("	motor[ port%d", m+1); // write changed values to the debugStream as motor[] commands
				writeDebugStream(" ] = %d", motorValue[m]);
				writeDebugStream("; ");
				motorChange = true;
			}
		}

		if ( motorChange == true ) // if any motor value changed this loop
		{
			timeSinceLastChange = (loopCounter - loopOfLastChange) * R_Freq ; // calculate elapsed time since last change
			timeCounter = loopCounter * R_Freq; // calculate current run time of autonomous
			writeDebugStream("	wait1Msec( P_Freq * %d", (loopCounter - loopOfLastChange));	// end the line of code with a wait equal to the time since the last motor change
			writeDebugStream(" ); // %d", timeSinceLastChange);	// end the line of code with a wait equal to the time since the last motor change
			writeDebugStreamLine(" wait");
			writeDebugStreamLine(" ");	// line break after wait
			writeDebugStreamLine("// %d", timeCounter);	//print the current time of the autonomous add line break between actions
			loopOfLastChange = loopCounter; // restart loopsSince count
		}

		// update motorVaule_Last
		for (int m = 0; m < 10; m++)
		{
			motorValue_Last[m] = 	motorValue[m];
		}
		motorChange = false;
		wait1Msec(R_Freq);
	}
}

task main()
{
	// clear previous recordings
	clearDebugStream();
	wait1Msec(100);
	// save current battery voltage to R_Batt
	R_Batt = nImmediateBatteryLevel;

	// countdown in debug stream
	writeDebugStreamLine("// Begin recording in: 3");
	wait1Msec(1000);
	writeDebugStreamLine("// Begin recording in: 2");
	wait1Msec(1000);
	writeDebugStreamLine("// Begin recording in: 1");
	wait1Msec(1000);

	// write header for autonomous code
	writeDebugStreamLine("// BEGIN AUTONOMOUS RECORDING");
	writeDebugStreamLine("/*---- START COPY -------------------------------------------------------------------------------------------------------------*/");
	writeDebugStreamLine("R_Freq = %d", R_Freq);
	writeDebugStreamLine(";");
	writeDebugStream("R_Batt = %d", R_Batt);
	writeDebugStreamLine(";");
	writeDebugStreamLine("replayFreq();");
	writeDebugStreamLine("");
	writeDebugStreamLine("//000");

	// start recording the vexRT signals
	startTask (recordMotorValues);

	// allow driver control for R_mSec miliseconds
	clearTimer(T1);
	while (time1[T1] < R_mSec)
	{
		userControlCode();
				motor[righttop] = vexRT[Ch2];
		motor[rightbottom]  = vexRT[Ch2];
		//Left side of the robot is controlled by the left joystick, Y-axis
		motor[lefttop] = vexRT[Ch3];
		motor[leftbottom]  = vexRT[Ch3];
		if(vexRT[Btn6D] == 1) {
			motor[hang] = -127;
		}
		if(vexRT[Btn6U] == 1) {
			motor[hang] = 127;
		}
		if(vexRT[Btn6D] == 0) {
			if(vexRT[Btn6U] == 0) {
				motor[hang] = 0;
			}
		}
		motor[lift1] = vexRT[Ch2Xmtr2];
		motor[lift2] = vexRT[Ch2Xmtr2];
		motor[claw]= vexRT[Ch3Xmtr2] / 3 * 2;
	}

	// stop recording the vexRT signals
	stopTask (recordMotorValues);

	writeDebugStreamLine("for (int i; i < 10; i++){ motor[i] = 0; }");
	writeDebugStreamLine("/*---------------------------------------------------------------------------------------------------------------END COPY-------*/");
	writeDebugStreamLine("// END AUTON RECORDING");

	// stop all motors
	for (int i; i < 10; i++)
	{
		motor[i] = 0;
	}
}
