#pragma config(Sensor, in1,    liftpotenright, sensorPotentiometer)
#pragma config(Sensor, in2,    liftpotenleft,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightencoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftencoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  clawrightencoder, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  clawleftencoder, sensorQuadEncoder)
#pragma config(Motor,  port2,           right,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           left,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           lift1,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           lift2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lift3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           clawright,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           clawleft,      tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("Globals")
#pragma DebuggerWindows("Motors")
#pragma DebuggerWindows("Sensors")
#pragma DebuggerWindows("debugStream")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
//LCD Display code.
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
//Declare count variable to keep track of our choice
int count = 0;
//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}


#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	//------------- Beginning of User Interface Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Cube Left");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 3;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "Time Left");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "Cube+Stars Left");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "Disabled");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:

			count = 0;

			break;
		}
	}
}

//FUNCTIONS: Convert chasis rotations to inches and vise versa for easy autonomous coding. Do this by having functions which before being
//called are given a value (inches) to move or rotate.
int inchesmoved = 0;
float inchestomove = 0;
int rightinches = 0;
int leftinches = 0;
float rightinchestomove = 0;
float leftinchestomove = 0;
float clawdegreetomove = 0;
int nextstep = 0;
int doomsdayclock = 0;


void moveforward()
{
	if(inchesmoved < inchestomove)
	{
		motor[right] = 127;
		motor[left] = 127;
		doomsdayclock = 0;
	}
	if(inchesmoved > inchestomove)
	{
		motor[right] = 127;
		motor[left] = 127;
		doomsdayclock = 0;
	}
	if(inchesmoved == inchestomove)
	{
	doomsdayclock = doomsdayclock + 1;
	}
	if(doomsdayclock == 50)
	{
		motor[left] = 0;
		motor[right] = 0;
		nextstep = nextstep + 1;
	}
}

void movebackward()
{
	if(inchesmoved > inchestomove)
	{
		motor[right] = -127;
		motor[left] = -127;
		doomsdayclock = 0;
	}
	if(inchesmoved < inchestomove)
	{
		motor[right] = 127;
		motor[left] = 127;
		doomsdayclock = 0;
	}
	if(inchesmoved == inchestomove)
	{
	doomsdayclock = doomsdayclock + 1;
	}
	if(doomsdayclock == 50)
	{
		motor[left] = 0;
		motor[right] = 0;
		nextstep = nextstep + 1;
	}
}
void turnright()
{
	if(abs(rightinches) < rightinchestomove)
	{
		motor[left] = 127;
		motor[right] = -127;
		doomsdayclock = 0;
	}
	if(abs(rightinches) > rightinchestomove)
	{
		motor[right] = -127;
		motor[left] = 127;
		doomsdayclock = 0;
	}
	if(abs(rightinches) == rightinchestomove)
	{
	doomsdayclock = doomsdayclock + 1;
	}
	if(doomsdayclock == 50)
	{
		motor[left] = 0;
		motor[right] = 0;
		nextstep = nextstep + 1;
	}
}

void turnleft()
{
	if(abs(leftinches) < leftinchestomove)
	{
		motor[left] = 127;
		motor[right] = -127;
		doomsdayclock = 0;
	}
	if(abs(leftinches) > leftinchestomove)
	{
		motor[right] = -127;
		motor[left] = 127;
		doomsdayclock = 0;
	}
	if(abs(leftinches) == leftinchestomove)
	{
	doomsdayclock = doomsdayclock + 1;
	}
	if(doomsdayclock == 50)
	{
		motor[left] = 0;
		motor[right] = 0;
		nextstep = nextstep + 1;
	}
}
void inchreset()
{
	SensorValue[rightencoder] = 0;
	SensorValue[leftencoder] = 0;
	SensorValue[clawrightencoder] = 0;
	SensorValue[clawleftencoder] = 0;
	rightinches = 0;
	leftinches = 0;
	inchesmoved = 0;
	inchestomove = 0;
	rightinchestomove = 0;
	leftinchestomove = 0;
	clawdegreetomove = 0;
	doomsdayclock = 0;
}
void raiselift()
{
	motor[lift1] = 127;
	motor[lift2] = 127;
	motor[lift3] = 127;
}
void stoplift()
{
	motor[lift1] = 0;
	motor[lift2] = 0;
	motor[lift3] = 0;
}
void lowerlift()
{
	motor[lift1] = -127;
	motor[lift2] = -127;
	motor[lift3] = -127;
}
void openclaw()
{
	if(SensorValue[clawleftencoder] > clawdegreetomove)
	{
	motor[clawleft] = 127;
	}
	if(SensorValue[clawrightencoder] > clawdegreetomove)
	{
	motor[clawright] = 127;
	}
	if(SensorValue[clawleftencoder] == clawdegreetomove)
	{
	motor[clawleft] = 0;
	}
	if(SensorValue[clawrightencoder] == clawdegreetomove)
	{
	motor[clawright] = 0;
	}
	if(SensorValue[clawrightencoder] == clawdegreetomove && SensorValue[clawleftencoder] == clawdegreetomove)
	{
	nextstep = nextstep + 1;
	}
}
void stopclaw()
{
	motor[clawleft] = 0;
	motor[clawright] = 0;
}
void closeclaw()
{
		if(SensorValue[clawleftencoder] < clawdegreetomove)
	{
	motor[clawleft] = -127;
	}
	if(SensorValue[clawrightencoder] < clawdegreetomove)
	{
	motor[clawright] = -127;
	}
	if(SensorValue[clawleftencoder] == clawdegreetomove)
	{
	motor[clawleft] = 0;
	}
	if(SensorValue[clawrightencoder] == clawdegreetomove)
	{
	motor[clawright] = 0;
	}
	if(SensorValue[clawrightencoder] == clawdegreetomove && SensorValue[clawleftencoder] == clawdegreetomove)
	{
	nextstep = nextstep + 1;
	}
}
//t functions
void openclawt()
{
	motor[clawleft] = 127;
	motor[clawright] = 127;
}
void closeclawt()
{
	motor[clawleft] = -127;
	motor[clawright] = -127;
}
void turnleftt()
{
	motor[left] = -127;
	motor[right] = 127;
}
void turnrightt()
{
	motor[left] = 127;
	motor[right] = -127;
}
void moveforwardt()
{
	motor[left] = 127;
	motor[right] = 127;
}
void movebackwardt()
{
	motor[left] = -127;
	motor[right] = -127;
}
void stopmovingt()
{
	motor[left] = 0;
	motor[right] = 0;
}
task algo()
{
	while(true)
	{
		rightinches = SensorValue[rightencoder] * 12.56 / 360;
		leftinches = SensorValue[leftencoder] * 12.56 / 360;
		clawdegreetomove = (SensorValue[leftencoder] + SensorValue[rightencoder]) / 2;
		inchesmoved = (leftinches + rightinches)/2;
		wait1Msec(10);
		//writeDebugStreamLine("left encoder count is %d", SensorValue[leftencoder]*-1 );
		//writeDebugStreamLine("right encoder count is %d", SensorValue[rightencoder]*-1 );
		//writeDebugStreamLine("inches moved is %d", inchesmoved);
		//writeDebugStreamLine("right inches moved is %d", rightinches);
		//writeDebugStreamLine("step count is %d", nextstep);
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	startTask (algo);
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Cube Left");
		SensorValue[leftencoder] = 0;
		SensorValue[rightencoder] = 0;
		//STEP 0 (Lower claw)
		nextstep = 1;
		raiselift();
		openclawt();
		wait1Msec(500);
		motor[lift1] = -40;
		motor[lift2] = -40;
		motor[lift3] = -40;
		wait1Msec(700);
		motor[lift1] = -50;
		motor[lift2] = -50;
		motor[lift3] = -50;
		//STEP 1 (move forward 23 inches)
		inchreset();
		inchestomove = 23;
		while(nextstep == 1)
		{
			moveforward();
		}
		inchreset();
		rightinchestomove = 4;
		while(nextstep == 2) //step 2 (turn for cube)
		{
			turnright();
		}
		stopclaw();
		inchreset();
		inchestomove = 20;
		while(nextstep == 3) //go for cube pham
		{
			moveforward();
		}
		closeclawt();
		wait1Msec(800);
		raiselift();
		wait1Msec(400);
		stopclaw();
		motor[lift1] = 20;
		motor[lift2] = 20;
		motor[lift3] = 20;
		inchreset();
		rightinchestomove = 6;//turn to drop cube pham
		while(nextstep == 4)
		{
			turnright();
		}
		inchreset();
		inchestomove = -18;
		while(nextstep == 5)
		{
			movebackward();
		}
		inchreset();
		raiselift();
		wait1Msec(1000);
		openclawt();
		wait1Msec(400);
		stopclaw();
		motor[lift1] = -90;
		motor[lift2] = -90;
		motor[lift3] = -90;
		wait1Msec(400);
		stopclaw();
		stoplift();
		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Time Left");
		displayLCDCenteredString(1, "is running!");
		//rest position for lift motors 1,2,3= 20//EMERGENCY FAILSAFE lolxdddddddddd
		motor[right] = 80;
		motor[left] = 80;
		raiselift();
		openclawt();
		wait1Msec(500);
		motor[lift1] = -40;
		motor[lift2] = -40;
		motor[lift3] = -40;
		wait1Msec(700);
		motor[lift1] = -60;
		motor[lift2] = -60;
		motor[lift3] = -60;
		turnrightt();
		wait1Msec(850);
		moveforwardt();
		wait1Msec(1000);
		closeclawt();
		wait1Msec(300);
		raiselift();
		wait1Msec(300);
		motor[lift1] = 20;
		motor[lift2] = 20;
		motor[lift3] = 20;
		stopclaw();
		turnrightt();
		wait1Msec(850);
		movebackwardt();
		wait1Msec(700);
		raiselift();
		wait1Msec(800);
		openclawt();
		wait1Msec(400);
		stoplift();
		stopmovingt();
		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Cube+Stars Left");
		displayLCDCenteredString(1, "is running!");
		/*
1st step: move forward 23 inches(from shaft encoder)
2nd step: point turn values should be 4 inches
3rd step: move forward 12 inches(from shaft encoder)
-open and lift
4th step: point turn values should be 4 inches
5th step: move back 27 inches(from shaft encoder)
-launch
6th step: move forward 31 inches(from shaft encoder)
7th step: repeat 6th step in reverses
		*/
		//STEP 0 (Lower claw)
		nextstep = 1;
		raiselift();
		openclawt();
		wait1Msec(500);
		motor[lift1] = -30;
		motor[lift2] = -30;
		motor[lift3] = -30;
		//STEP 1 (move forward 23 inches)
		inchreset();
		inchestomove = 23;
		while(nextstep == 1)
		{
			moveforward();
		}
		inchreset();
		rightinchestomove = 4;
		while(nextstep == 2) //step 2 (turn for cube)
		{
			turnright();
		}
		stopclaw();
		inchreset();
		inchestomove = 24;
		while(nextstep == 3) //go for cube pham
		{
			moveforward();
		}
		closeclawt();
		wait1Msec(800);
		raiselift();
		wait1Msec(400);
		//thuswer
		motor[lift1] = 20;
		motor[lift2] = 20;
		motor[lift3] = 20;
		inchreset();
		rightinchestomove = 5;//turn to drop cube pham
		while(nextstep == 4)
		{
			turnright();
		}
		stopclaw();
		inchreset();
		inchestomove = -18;
		while(nextstep == 5)
		{
			movebackward();
		}
		inchreset();
		raiselift();
		wait1Msec(1400);
		openclawt();
		wait1Msec(200);
		stopclaw();
		lowerlift();
		wait1Msec(1100);
		stopclaw();
		stoplift();

		inchestomove = 26;
		while(nextstep == 6)//go 4 stars
		{
			moveforward();
		}
		inchreset();
		stoplift();
		closeclawt();
		wait1Msec(1000);
		wait1Msec(600);
		inchestomove = -26;
		while(nextstep == 7)
		{
			movebackward();
		}
		inchreset();
		raiselift();
		wait1Msec(1000);
		openclawt();
		wait1Msec(400);
		stopclaw();
		motor[lift1] = -90;
		motor[lift2] = -90;
		motor[lift3] = -90;
		wait1Msec(400);
		inchestomove = 26;
		while(nextstep == 8)//stars again
		{
			moveforward();
		}
		inchreset();
		stoplift();
		closeclawt();
		wait1Msec(600);
		inchestomove = -26;
		while(nextstep == 9)
		{
			movebackward();
		}
		inchreset();
		raiselift();
		wait1Msec(1000);
		openclawt();
		wait1Msec(400);
		stopclaw();
		motor[lift1] = -90;
		motor[lift2] = -90;
		motor[lift3] = -90;
		wait1Msec(400);
		inchestomove = 26;
		while(nextstep == 10)
		{
			moveforward();
		}
		inchreset();
		stoplift();
		closeclawt();
		wait1Msec(600);
		inchestomove = -26;
		while(nextstep == 11)
		{
			movebackward();
		}
		inchreset();
		stopclaw();
		stoplift();

		break;

	case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "Disabled");
		displayLCDCenteredString(1, "is running!");
		raiselift();
		openclawt();
		wait1Msec(500);
		motor[lift1] = -40;
		motor[lift2] = -40;
		motor[lift3] = -40;
		wait1Msec(700);
		motor[lift1] = -50;
		motor[lift2] = -50;
		motor[lift3] = -50;
		wait1Msec(300);
		stopclaw();
		stoplift();

		break;
	default:
		displayLCDCenteredString(0, "coding is not");
		displayLCDCenteredString(1, "so great.");
		break;
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
int clawleftvalue;
int clawrightvalue;
bool clawsync = true;
task usercontrol()
{
	SensorValue[clawleftencoder] = 0;
	SensorValue[clawrightencoder] = 0;
	// User control code here, inside the loop
	//	while (true)
	//		wait1Msec(1000);
	while (true)
	{
		//make coding great again - an initiative by sulaiman ghori
		//Claw lock, checks if there is a difference in angles of each claw and changes power accordingly
		if(SensorValue[clawrightencoder] > SensorValue[clawleftencoder] && clawsync == true){
			clawleftvalue = 20;
			clawrightvalue = -20;
		}
		if(SensorValue[clawrightencoder] < SensorValue[clawleftencoder] && clawsync == true){
			clawleftvalue = -20;
			clawrightvalue = 20;
		}
		if(SensorValue[clawrightencoder] < SensorValue[clawleftencoder] - 20 && SensorValue[clawrightencoder] > SensorValue[clawleftencoder] + 20)
		{
		clawleftvalue = 0;
		clawrightvalue = 0;
		}
		//Right side of the robot is controlled by the right joystick, Y-axis
		motor[right] = vexRT[Ch2];
		//Left side of the robot is controlled by the left joystick, Y-axis
		motor[left]  = vexRT[Ch3];
		motor[lift1] = vexRT[Ch2Xmtr2];
		motor[lift2] = vexRT[Ch2Xmtr2];
		motor[lift3] = vexRT[Ch2Xmtr2];
		if(vexRT[Ch3Xmtr2] > 20 || vexRT[Ch3Xmtr2] < -20){
			motor[clawleft]= -vexRT[Ch3Xmtr2];
			motor[clawright] = -vexRT[Ch3Xmtr2];
			clawsync = true;
		}
		else{
			motor[clawleft] = clawleftvalue;
			motor[clawright] = clawrightvalue;
		}
		//Button for emergencieseeieieis (or however u speel to lazy rn pham)
		if(vexRT[Btn8DXmtr2] == 1)
		{
			clawsync = false;
		}
		if(vexRT[Btn8UXmtr2] == 1)
		{
			clawsync = true;
		}
		if(vexRT[Btn5DXmtr2] == 1)
		{
			clawleftvalue = clawleftvalue + 1;
		}
		if(vexRT[Btn5UXmtr2] == 1)
		{
			clawleftvalue = clawleftvalue - 1;
		}
		if(vexRT[Btn6DXmtr2] == 1)
		{
			clawrightvalue = clawrightvalue + 1;
		}
		if(vexRT[Btn6UXmtr2] == 1)
		{
			clawrightvalue = clawrightvalue - 1;
		}
		//Debugging
		displayLCDCenteredString(0, "make coding");
		displayLCDCenteredString(1, "great again -sg");
		//writeDebugStreamLine("claw count is right %d left %d", clawencoderrightvalue, clawencoderleftvalue);
	}
}
