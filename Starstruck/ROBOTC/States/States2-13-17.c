#pragma config(Sensor, in1,    fd,             sensorPotentiometer)
#pragma config(Sensor, in2,    dd,             sensorPotentiometer)
#pragma config(Sensor, in3,    liftpotenright, sensorPotentiometer)
#pragma config(Sensor, in4,    liftpotenleft,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightencoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftencoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           right,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           left,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           lift1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           lift2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lift3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           clawright,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           clawleft,      tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
//LCD Display code.
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
//Declare count variable to keep track of our choice
int count = 0;
//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}


#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	//------------- Beginning of User Interface Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Red Left");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 3;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "Red Right");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "Blue Left");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "Blue Right");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:

			count = 0;

			break;
		}
	}
}

//FUNCTIONS: Convert chasis rotations to inches and vise versa for easy autonomous coding. Do this by having functions which before being
//called are given a value (inches) to move or rotate.
int inchesmoved = 0;
int inchestomove = 0;
int rightinches = 0;
int leftinches = 0;
int rightinchestomove = 0;
int leftinchestomove = 0;


void moveforward()
{
	motor[right] = 127;
	motor[left] = 127;
	waitUntil(abs(inchesmoved) < inchestomove);
	motor[left] = 0;
	motor[right] = 0;
}

void movebackward()
{
	motor[left] = -127;
	motor[right] = -127;
	waitUntil(abs(inchesmoved) < inchestomove);
	motor[right] = 0;
	motor[left] = 0;
}
void turnright()
{
	motor[left] = 127;
	motor[right] = -127;
	waitUntil(abs(rightinches) < rightinchestomove);
	motor[right] = 0;
	motor[left] = 0;
}
void turnleft()
{
	motor[left] = -127;
	motor[right] = 127;
	waitUntil(abs(leftinches) < leftinchestomove);
	motor[left] = 0;
	motor[right] = 0;
}
void inchreset()
{
	SensorValue[rightencoder] = 0;
	SensorValue[leftencoder] = 0;
	rightinches = 0;
	leftinches = 0;
	inchesmoved = 0;
}
void Launch()
{
	motor[right] = -50;
	motor[left] = -50;
	motor[lift1] = 127;
	motor[lift2] = 127;
	motor[lift3] = 127;
	wait1Msec(500);
	motor[clawleft] = -127;
	motor[clawright] = -127;
	wait1Msec(300);
	motor[lift1] = -127;
	motor[lift2] = -127;
	motor[lift3] = -127;
	wait1Msec(300);
	motor[lift1] = 0;
	motor[lift2] = 0;
	motor[lift3] = 0;
	motor[left] = 127;
	motor[right] = 127;
}
task algo()
{
	while(true)
	{
		rightinches = SensorValue[rightencoder] * 12.56 / 360;
		leftinches = SensorValue[leftencoder] * -12.56 / 360;
		inchesmoved = (leftinches + rightinches)/2;
		wait1Msec(10);
		//writeDebugStreamLine("left encoder count is %d", SensorValue[leftencoder]*-1 );
		//writeDebugStreamLine("right encoder count is %d", SensorValue[rightencoder]*-1 );
		//writeDebugStreamLine("inches moved is %d", inchesmoved);
		//writeDebugStreamLine("right inches moved is %d", rightinches);
		//writeDebugStreamLine("step count is %d", nextstep);
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
	startTask (algo);
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Red Left");
		SensorValue[leftencoder] = 0;
		SensorValue[rightencoder] = 0;
		inchestomove = 26;
		motor[clawleft] = 80;
		motor[clawright] = 80;
		moveforward();
		inchestomove = 0;
		inchreset();
		rightinchestomove = 6;
		turnright();
		motor[clawright] = 0;
		motor[clawleft] = 0;
		rightinchestomove = 0;
		inchreset();
		inchestomove = 28;
		moveforward();
		inchestomove = 0;
		inchreset();
		leftinchestomove = 4.7;
		motor[clawright] = 127;
		motor[clawleft] = 127;
		wait1Msec(600);
		motor[clawleft] = 80;
		motor[clawright] = 80;
		wait1Msec(400);
		motor[lift1] = 127;
		motor[lift2] = 127;
		wait1Msec(100);
		turnleft();
		leftinchestomove = 0;
		inchreset();
		inchestomove = 24;
		moveforward();
		inchestomove = 0;
		inchreset();
		inchestomove = -20;
		motor[clawleft] = -127;
		motor[clawright] = -127;
		wait1Msec(500);
		motor[clawright] = 80;
		motor[clawleft] = 80;
		movebackward();
		motor[clawright] = 0;
		motor[clawleft] = 0;
		motor[lift1] = 0;
		motor[lift2] = 0;
		movebackward();
		inchestomove = 0;
		inchreset();
		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Red Right");
		displayLCDCenteredString(1, "is running!");



		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Blue Left");
		displayLCDCenteredString(1, "is running!");

		break;

	case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "Blue Right");
		displayLCDCenteredString(1, "is running!");


		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!!");
		break;
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
int clawleftvalue = 0;
int clawrightvalue = 0;
int clawencoderleftvalue = 0;
int clawencoderrightvalue = 0;

task usercontrol()
{
	SensorValue[clawleftencoder] = 0;
	SensorValue[clawrightencoder] = 0;
	// User control code here, inside the loop
//	while (true)
//		wait1Msec(1000);
	while (true)
	{
		//make coding great again - an initiative by sulaiman ghori
		//Claw lock, checks if there is a difference in angles of each claw and changes power accordingly

		if(clawencoderrightvalue > clawencoderleftvalue +20 && clawencoderrightvalue < clawencoderleftvalue -20){
			clawleftvalue = 0;
			clawrightvalue = 0;
			writeDebugStreamLine("claw is centered");
		}
		else{
		if(clawencoderrightvalue < clawencoderleftvalue){ //+20 || clawencoderrightvalue < clawencoderleftvalue -20){
			clawleftvalue = -30;
			clawrightvalue = 30;
			writeDebugStreamLine("claw left is greater, increase left decrease right");
		}
		else{
		if(clawencoderrightvalue > clawencoderleftvalue){ //+20 || clawencoderrightvalue > clawencoderleftvalue -20){
			clawleftvalue = 30;
			clawrightvalue = -30;
			writeDebugStreamLine("claw right is greater, increase right decrease left");
			}}}
		//Right side of the robot is controlled by the right joystick, Y-axis
		motor[right] = vexRT[Ch2];
		//Left side of the robot is controlled by the left joystick, Y-axis
		motor[left]  = vexRT[Ch3];
		motor[lift1] = vexRT[Ch2Xmtr2];
		motor[lift2] = vexRT[Ch2Xmtr2];
		motor[lift3] = vexRT[Ch2Xmtr2];
		//Deadzones to activate claw sync
		if(vexRT[Ch3Xmtr2] > 20 || vexRT[Ch3Xmtr2] < -20){
			motor[clawleft]= vexRT[Ch3Xmtr2];
			motor[clawright] = vexRT[Ch3Xmtr2];
		}
		else{
			motor[clawleft] = -clawleftvalue;
			motor[clawright] = -clawrightvalue;
		}
		if(vexRT[Btn8DXmtr2] == 1){
			Launch();
		}
		//Debugging
		//clawencoderleftvalue = SensorValue[clawleftencoder];
		//clawencoderrightvalue = SensorValue[clawrightencoder];
		//writeDebugStreamLine("claw count is right %d left %d", clawencoderrightvalue, clawencoderleftvalue);
		displayLCDNumber(1, 1, clawleftencoder, 1);
		displayLCDNumber(0, 1, clawrightencoder, 1);
		wait1Msec(10);
	}
}
