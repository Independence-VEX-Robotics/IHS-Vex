#pragma config(Sensor, in1,    clawpotenright, sensorPotentiometer)
#pragma config(Sensor, in2,    clawpotenleft,  sensorPotentiometer)
#pragma config(Sensor, in3,    liftpotenright, sensorPotentiometer)
#pragma config(Sensor, in4,    liftpotenleft,  sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightencoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftencoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           right,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           left,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           lift1,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           lift2,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           lift3,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           clawright,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           clawleft,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
//LCD Display code.
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
//Declare count variable to keep track of our choice
int count = 0;
//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}


#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  //------------- Beginning of User Interface Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	bLCDBacklight = true;
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Red Left");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 3;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "Red Right");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "Blue Left");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "Blue Right");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:

			count = 0;

			break;
		}
	}
}

//FUNCTIONS: Convert chasis rotations to inches and vise versa for easy autonomous coding. Do this by having functions which before being
//called are given a value (inches) to move or rotate.
int inchesmoved = 0;
int inchestomove = 0;
int rightinches = 0;
int leftinches = 0;
int nextstep = 0;
int rightinchestomove = 0;
int leftinchestomove = 0;


void moveforward()
{
	if(inchesmoved < inchestomove)
	{
		motor[right] = 127;
		motor[left] = 127;
	}
	else
	{
		motor[left] = 0;
		motor[right] = 0;
		nextstep = nextstep + 1;
	}
}

void movebackward()
{
	if(inchesmoved < inchestomove)
	{
		motor[left] = -127;
		motor[right] = -127;
	}
	else
	{
		motor[right] = 0;
		motor[left] = 0;
		nextstep = nextstep + 1;
	}
}
void turnright()
{
	if(abs(rightinches) < rightinchestomove)
	{
		motor[left] = 127;
		motor[right] = -127;
	}
	if(abs(rightinches) >= rightinchestomove)
	{
		motor[right] = 0;
		motor[left] = 0;
		nextstep = nextstep + 1;
	}
}
void turnleft()
{
	if(abs(leftinches) < leftinchestomove)
	{
		motor[left] = -127;
		motor[right] = 127;
	}
	if(abs(leftinches) > leftinchestomove)
	{
		motor[left] = 0;
		motor[right] = 0;
		nextstep = nextstep + 1;
	}
}
void inchreset()
{
	SensorValue[rightencoder] = 0;
	SensorValue[leftencoder] = 0;
	rightinches = 0;
	leftinches = 0;
	inchesmoved = 0;
}

task algo()
{
	while(true)
	{
	rightinches = SensorValue[rightencoder] * 12.56 / 360;
  leftinches = SensorValue[leftencoder] * -12.56 / 360;
  inchesmoved = (leftinches + rightinches)/2;
  wait1Msec(10);
  //writeDebugStreamLine("left encoder count is %d", SensorValue[leftencoder]*-1 );
  //writeDebugStreamLine("right encoder count is %d", SensorValue[rightencoder]*-1 );
  //writeDebugStreamLine("inches moved is %d", inchesmoved);
  //writeDebugStreamLine("right inches moved is %d", rightinches);
  //writeDebugStreamLine("step count is %d", nextstep);
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
  startTask (algo);
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Red Left");
		displayLCDNumber(1, 0, nextstep, 1);
		SensorValue[leftencoder] = 0;
		SensorValue[rightencoder] = 0;
		inchestomove = 26;
		nextstep = 1;
		motor[clawleft] = 80;
		motor[clawright] = 80;
		while (nextstep == 1)
		{
			moveforward();
		}
		inchestomove = 0;
		inchreset();
		rightinchestomove = 6;
		while (nextstep == 2)
		{
			turnright();
		}
		motor[clawright] = 0;
		motor[clawleft] = 0;
		rightinchestomove = 0;
		inchreset();
		inchestomove = 28;
		while (nextstep == 3)
		{
			moveforward();
		}
		inchestomove = 0;
		inchreset();
		leftinchestomove = 4.7;
		motor[clawright] = 127;
		motor[clawleft] = 127;
		wait1Msec(600);
		motor[clawleft] = 80;
		motor[clawright] = 80;
		wait1Msec(400);
		motor[lift1] = 127;
		motor[lift2] = 127;
		wait1Msec(100);
		while (nextstep == 4)
		{
			turnleft();
		}
		leftinchestomove = 0;
		inchreset();
		inchestomove = 24;
			while (nextstep == 5)
		{
			moveforward();
		}
		inchestomove = 0;
		inchreset();
		inchestomove = -20;
		motor[clawleft] = -127;
		motor[clawright] = -127;
		wait1Msec(500);
		motor[clawright] = 80;
		motor[clawleft] = 80;
				while (nextstep == 6)
		{
			movebackward();
		}
		motor[clawright] = 0;
		motor[clawleft] = 0;
		motor[lift1] = 0;
		motor[lift2] = 0;
			while (nextstep == 7)
		{
			movebackward();
		}
		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Red Right");
		displayLCDCenteredString(1, "is running!");



		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Blue Left");
		displayLCDCenteredString(1, "is running!");

		break;

	case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "Blue Right");
		displayLCDCenteredString(1, "is running!");


		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!!");
		break;
	}
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
float clawleftvalue = 0;
float clawrightvalue = 0;
int clawpotenleftvalue = 0;
int clawpotenrightvalue = 0;

task usercontrol()
{
	SensorValue[clawpotenleft] = 0;
	SensorValue[clawpotenright] = 0;
  // User control code here, inside the loop
  while (true)
  {
		//make coding great again - an initiative by sulaiman ghori
		//Claw lock
		if(clawpotenrightvalue < clawpotenleftvalue){
			clawleftvalue = clawleftvalue - .1;
			clawrightvalue = clawrightvalue + .1;
		}
		if(clawpotenrightvalue > clawpotenleftvalue){
			clawleftvalue = clawleftvalue + .1;
			clawrightvalue = clawrightvalue - .1;
		}
		//Right side of the robot is controlled by the right joystick, Y-axis
		motor[right] = vexRT[Ch2];
		//Left side of the robot is controlled by the left joystick, Y-axis
		motor[left]  = vexRT[Ch3];
		motor[lift1] = vexRT[Ch2Xmtr2];
		motor[lift2] = vexRT[Ch2Xmtr2];
		if(vexRT[Ch3Xmtr2] > 20 || vexRT[Ch3Xmtr2] < -20){
			motor[clawleft]= vexRT[Ch3Xmtr2];
			motor[clawright] = vexRT[Ch3Xmtr2];
			motor[port8] = vexRT[Ch3Xmtr2];
			}
		else{
			motor[clawleft] = clawleftvalue;
			motor[clawright] = clawrightvalue;
		}
		clawpotenleftvalue = SensorValue[clawpotenleft];
		clawpotenrightvalue = SensorValue[clawpotenright];
		writeDebugStreamLine("right claw count is %d", SensorValue[clawpotenright]);
		displayLCDNumber(1, 1, clawpotenrightvalue, 1);
		displayLCDNumber(0, 1, clawpotenleftvalue, 1);
  }
}
